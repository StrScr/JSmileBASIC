/*
    SmileBASIC Syntax Analyzer by StrScr
    To be used with CUP.
*/

package JSmileBASIC;

import java.io.*;
import java_cup.runtime.*;

parser code
{:
    public void syntax_error(Symbol s){
        report_error("Error de sintaxis. Linea: " + (s.right + 1) +
            " Columna: " + s.left + ". Texto: \"" + s.value + "\"", null);
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        report_fatal_error("Fatal Error: " + s.value, null);
    }

:}

/* Terminals */

terminal IF, THEN, ELSE, ELSEIF, ENDIF;
terminal ON, CASE, DEFAULT, WON;

terminal FOR, TO, STEP, NEXT;
terminal WHILE, WEND;
terminal REPEAT, UNTIL;
terminal CONTINUE, BREAK;

terminal STOP;

terminal GOTO, GOSUB;

terminal DEF, COMMON, CALL, RETURN, OUT, END;

terminal VAR, DIM;
terminal INC, DEC, SWAP;

terminal PRINT, QUESTION;

terminal INPUT, LINPUT;

terminal READ, DATA, RESTORE;

terminal EXEC, USE;

terminal TRUE, FALSE;

terminal LPAREN, RPAREN;
terminal LBRACK, RBRACK;
terminal COMMA, SEMICOLON;

terminal EQ;
terminal EQEQ, NOTEQ, LT, LTEQ, GT, GTEQ;

terminal NOT, ANDAND, OROR;

terminal PLUS, MINUS;
terminal MULT, DIV, MOD, INTEGER_DIV;

terminal BIT_AND, BIT_OR, BIT_XOR, BIT_NOT;

terminal LSHIFT, RSHIFT;

terminal NUMBER, DECIMAL;
terminal STRING;

terminal IDENTIFIER_STRING, IDENTIFIER_DECIMAL, IDENTIFIER_INTEGER;
terminal LABEL;

terminal LINEEND, COLON;

// Used for precedence only
terminal UMINUS;

/* Non Terminals */
/*  Shortening Map
    stmnt -> Statement
    expr -> Expression
    op -> Operator
    bin -> Binary
    sep -> Separator
*/

//Statements
non terminal stmnt_list, stmnt;
non terminal declaration, asig;
non terminal conditional, loop;
non terminal if_stmnt, if_2, on_stmnt;
non terminal goto_stmnt;
non terminal def_stmnt, call_stmnt;
non terminal increment_stmnt, swap_stmnt;
non terminal print_stmnt;
non terminal for_stmnt, while_stmnt, repeat_stmnt, stmnt_loop_list, stmnt_loop;
non terminal sep;
//TODO: read, data, restore, exec, use
//Expressions
non terminal expr, literal, numeric, id;
non terminal math_op_mult, math_op_sum;
non terminal bin_relation_op, bin_bit_op, bin_logic_op, bit_shift, unary_op;

/* Precedence */
precedence left ANDAND, OROR;
precedence left BIT_AND, BIT_OR, BIT_XOR;
precedence left EQEQ, NOTEQ, LT, LTEQ, GT, GTEQ;
precedence left LSHIFT, RSHIFT;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD, INTEGER_DIV;
precedence left UMINUS, NOT, BIT_NOT;

/* Grammar */

start with stmnt_list;

stmnt_list   ::= stmnt
            |   stmnt sep stmnt_list
            ;
stmnt       ::= declaration | asig | conditional | loop | goto_stmnt | def_stmnt | increment_stmnt
            | swap_stmnt | print_stmnt | call_stmnt | sep
            | LABEL | STOP | END
            ;//TODO
sep         ::= LINEEND | COLON;

//Statements
declaration ::= VAR id | DIM id
            |   VAR asig | DIM asig
            ;//include arrays
asig        ::= id EQ expr
            |   id LBRACK expr RBRACK EQ expr
            ;

conditional ::= if_stmnt | on_stmnt;
if_stmnt    ::= IF expr THEN stmnt_list if_2 sep ENDIF;
if_2        ::= sep ELSEIF expr THEN stmnt_list sep if_2
            |   sep ELSE stmnt_list
            |   empty
            ;

loop        ::= for_stmnt | while_stmnt | repeat_stmnt;
for_stmnt   ::= FOR ID EQ NUMBER TO NUMBER sep stmnt_list sep NEXT
            |   FOR ID EQ NUMBER TO NUMBER STEP NUMBER sep stmnt_list sep NEXT
            ;
while_stmnt ::= WHILE expr sep stmnt_loop_list sep WEND;
repeat_stmnt::= REPEAT sep stmnt_loop_list sep UNTIL expr;
stmnt_loop_list ::= stmnt_loop
                |   stmnt_loop sep stmnt_loop_list;
stmnt_loop  ::= stmnt | BREAK | CONTINUE;

//Expressions
expr    ::= expr bin_logic_op expr
        |   expr bin_bit_op expr
        |   expr bin_logic_op expr
        |   expr bit_shift expr
        |   expr math_op_sum expr
        |   expr math_op_mult expr
        |   unary_op expr
        |   LPAREN expr RPAREN
        |   literal
        |   id
        ;

//Expression Terminal Groups
unary_op        ::= MINUS %prec UMINUS | NOT | BIT_NOT;
math_op_mult    ::= MULT | DIV | MOD | INTEGER_DIV;
math_op_sum     ::= PLUS | MINUS;
bit_shift       ::= LSHIFT | RSHIFT;
bin_relation_op ::= EQEQ | NOTEQ | LT | LTEQ | GT | GTEQ;
bin_bit_op      ::= BIT_AND | BIT_OR | BIT_XOR;
bin_logic_op    ::= ANDAND | OROR;
literal     ::= NUMBER | DECIMAL | STRING | TRUE | FALSE;
numeric     ::= IDENTIFIER_INTEGER | IDENTIFIER_DECIMAL | NUMBER | DECIMAL | TRUE | FALSE;
id          ::= IDENTIFIER_INTEGER | IDENTIFIER_DECIMAL | IDENTIFIER_STRING;
