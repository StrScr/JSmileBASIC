/*
    SmileBASIC Syntax Analyzer by StrScr
    To be used with CUP.
*/

package JSmileBASIC;

import java.io.*;
import java_cup.runtime.*;

parser code
{:
    public void syntax_error(Symbol s){
        report_error("Error de sintaxis. Linea: " + (s.right + 1) +
            " Columna: " + s.left + ". Texto: \"" + s.value + "\"", null);
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        report_fatal_error("Fatal Error: " + s.value, null);
    }

:}

/* Terminals */

terminal IF, THEN, ELSE, ELSEIF, ENDIF;
terminal ON, CASE, DEFAULT, WON;

terminal FOR, TO, STEP, NEXT;
terminal WHILE, WEND;
terminal REPEAT, UNTIL;
terminal CONTINUE, BREAK;

//terminal STOP;

terminal GOTO, GOSUB;

terminal DEF, CALL, RETURN, OUT, END;
//terminal COMMON;

terminal VAR, DIM;
terminal INC, DEC, SWAP;

terminal PRINT, QUESTION;

terminal INPUT, LINPUT;

//terminal READ, DATA, RESTORE;

//terminal EXEC, USE;

terminal TRUE, FALSE;

terminal LPAREN, RPAREN;
terminal LBRACK, RBRACK;
terminal COMMA, SEMICOLON;

terminal EQ;
terminal EQEQ, NOTEQ, LT, LTEQ, GT, GTEQ;

terminal NOT, ANDAND, OROR;

terminal PLUS, MINUS;
terminal MULT, DIV, MOD, INTEGER_DIV;

terminal BIT_AND, BIT_OR, BIT_XOR, BIT_NOT;

terminal LSHIFT, RSHIFT;

terminal NUMBER, DECIMAL;
terminal STRING;

terminal IDENTIFIER_STRING, IDENTIFIER_DECIMAL, IDENTIFIER_INTEGER;
terminal LABEL;

terminal LINEEND, COLON;

// Used for precedence only
terminal UMINUS;

/* Non Terminals */
/*  Shortening Map
    stmnt -> Statement
    expr -> Expression
    op -> Operator
    bin -> Binary
    sep -> Separator
    func -> Function
*/

//Statements
non terminal stmnt_list, stmnt;
non terminal declaration, asig;
non terminal conditional, loop;
non terminal if_stmnt, if_2, on_stmnt;
non terminal goto_stmnt;
non terminal def_stmnt, call_stmnt, var_list;
non terminal def_params, call_argmts;
non terminal func_call;
non terminal simp_func_call, multi_func_call, method_call;
non terminal increment_stmnt, swap_stmnt;
non terminal print_stmnt, print_list;
non terminal input_stmnt;
non terminal for_stmnt, while_stmnt, repeat_stmnt, stmnt_loop_list, stmnt_loop;
non terminal sep;
//TODO: read, data, restore, exec, use
//Expressions
non terminal expr, literal, numeric, id;
non terminal math_op_mult, math_op_sum;
non terminal bin_relation_op, bin_bit_op, bin_logic_op, bit_shift, unary_op;

/* Precedence */
precedence left ANDAND, OROR;
precedence left BIT_AND, BIT_OR, BIT_XOR;
precedence left EQEQ, NOTEQ, LT, LTEQ, GT, GTEQ;
precedence left LSHIFT, RSHIFT;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD, INTEGER_DIV;
precedence left UMINUS, NOT, BIT_NOT;

/* Grammar */

start with stmnt_list;

stmnt_list   ::= stmnt
            |   stmnt sep stmnt_list
            ;
stmnt       ::= declaration | asig | conditional | loop | goto_stmnt | def_stmnt | increment_stmnt
            | swap_stmnt | print_stmnt | input_stmnt | call_stmnt | func_call | sep
            | LABEL | STOP | END | RETURN
            ;//TODO
sep         ::= LINEEND | COLON;

//Statements
declaration ::= VAR id | DIM id
            |   VAR asig | DIM asig
            ;//include arrays
asig        ::= id EQ expr
            |   id LBRACK expr RBRACK EQ expr
            ;

conditional ::= if_stmnt | on_stmnt;
if_stmnt    ::= IF expr THEN stmnt_list if_2 sep ENDIF
            ;
if_2        ::= sep ELSEIF expr THEN stmnt_list sep if_2
            |   sep ELSE stmnt_list
            |   empty
            ;
on_stmnt    ::= ON expr
            ;//TODO

loop        ::= for_stmnt | while_stmnt | repeat_stmnt;
for_stmnt   ::= FOR ID EQ NUMBER TO NUMBER sep stmnt_list sep NEXT
            |   FOR ID EQ NUMBER TO NUMBER STEP NUMBER sep stmnt_list sep NEXT
            ;
while_stmnt ::= WHILE expr sep stmnt_loop_list sep WEND
            ;
repeat_stmnt::= REPEAT sep stmnt_loop_list sep UNTIL expr
            ;
stmnt_loop_list ::= stmnt_loop
                |   stmnt_loop sep stmnt_loop_list;
stmnt_loop  ::= stmnt | BREAK | CONTINUE;

goto_stmnt  ::= GOTO LABEL
            |   GOSUB LABEL
            ;

def_stmnt   ::= DEF id def_params sep stmnt_list sep END
            ;
def_params  ::= LPAREN var_list RPAREN
            |;

call_stmnt  ::= CALL STRING call_argmts OUT var_list
            | ID EQ CALL LPAREN STRING call_argmts RPAREN ;
call_argmts ::= COMA ID call_argmts
            | COMA ID
            |;

func_call   ::= simp_func_call | multi_func_call | method_call;
simp_func_call  ::= id LPAREN var_list RPAREN
                |   id LPAREN RPAREN
                ;
multi_func_call ::= id var_list OUT var_list
                |   id OUT var_list
                ;
method_call ::= id
            ;//Hopefully won't cause trouble

increment_stmnt ::= INC id
                |   INC id COMMA expr
                |   DEC id
                |   DEC id COMMA expr
                ;

swap_stmnt  ::= SWAP id COMMA id
            ;

print_stmnt ::= PRINT print_list
            |   QUESTION print_list
            ;
print_list  ::= expr COMMA print_list
            |   expr SEMICOLON print_list
            |   expr
            |   empty
            ;

input_stmnt ::= INPUT STRING SEMICOLON var_list
            |   INPUT STRING COMMA var_list
            |   INPUT var_list
            |   LINPUT STRING SEMICOLON IDENTIFIER_STRING
            ;

//Expressions
expr    ::= expr bin_logic_op expr
        |   expr bin_bit_op expr
        |   expr bin_logic_op expr
        |   expr bit_shift expr
        |   expr math_op_sum expr
        |   expr math_op_mult expr
        |   unary_op expr
        |   LPAREN expr RPAREN
        |   literal
        |   id
        |   simp_func_call
        ;

//Expression Terminal Groups
unary_op        ::= MINUS %prec UMINUS | NOT | BIT_NOT;
math_op_mult    ::= MULT | DIV | MOD | INTEGER_DIV;
math_op_sum     ::= PLUS | MINUS;
bit_shift       ::= LSHIFT | RSHIFT;
bin_relation_op ::= EQEQ | NOTEQ | LT | LTEQ | GT | GTEQ;
bin_bit_op      ::= BIT_AND | BIT_OR | BIT_XOR;
bin_logic_op    ::= ANDAND | OROR;
literal     ::= NUMBER | DECIMAL | STRING | TRUE | FALSE;
numeric     ::= IDENTIFIER_INTEGER | IDENTIFIER_DECIMAL | NUMBER | DECIMAL | TRUE | FALSE;
id          ::= IDENTIFIER_INTEGER | IDENTIFIER_DECIMAL | IDENTIFIER_STRING;
