/*
    SmileBASIC Syntax Analyzer by StrScr
    To be used with CUP.

    TODO:
        Check other TODOs throughout code
        Allow for multidimensional arrays (Currently one-dimensional)
*/

import java.io.*;
import java_cup.runtime.*;

action code
{:
    int nodeid=0;
    
    void BuildAstAsDot(Node n){
        StringBuilder sb = new StringBuilder();
        sb.append("digraph AST {\n");
        sb.append(NodeToDot(n,"program"));
        sb.append("}");
        try (PrintWriter out = new PrintWriter("ast.dot")) {
            out.println(sb.toString());
        }catch(Exception e){
            System.out.println("Error al escribir AST a archivo.");
        }
    }

    String NodeToDot(Node n, String parent){
        if(n!=null){
            String dotid = "node" + nodeid;
            nodeid++;
            StringBuilder sb = new StringBuilder();
            Node[] childNodes = n.getChildren();
            sb.append(dotid + " [label=\"" + n.desc + "\"];\n");
            sb.append(parent + " -> " + dotid + ";\n");
            if(childNodes!=null){
                /* for(Node c : childNodes){
                    sb.append(NodeToDot(c,dotid));
                } */
                for(int i=0; i<childNodes.length; i++){
                    sb.append(NodeToDot(childNodes[i],dotid));
                }
            }
            return sb.toString();
        }
        return "";
    }
:}

parser code
{:
    public void syntax_error(Symbol s){
        report_error("Error Sintactico: Ln " + (s.left + 1) +
            ", Col " + (s.right+1) + ". Simbolo " + sym.terminalNames[s.sym] + ((s.value==null)?"":": "+s.value) +"\n", null);
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        report_fatal_error("Error Sintactico Fatal: " + s + "\n", null);
    }

:}

/* Terminals */

terminal IF, THEN, ELSE, ELSEIF, ENDIF;
terminal ON, CASE, DEFAULT, WON;

terminal FOR, TO, STEP, NEXT;
terminal WHILE, WEND;
terminal REPEAT, UNTIL;
terminal CONTINUE, BREAK;

//terminal STOP;

terminal GOTO, GOSUB;

terminal DEF, CALL, RETURN, OUT, END;
//terminal COMMON;

terminal VAR, DIM;
terminal INC, DEC, SWAP;

terminal PRINT, QUESTION;

terminal INPUT, LINPUT;

//terminal READ, DATA, RESTORE;

//terminal EXEC, USE;

terminal TRUE, FALSE;

terminal LPAREN, RPAREN;
terminal LBRACK, RBRACK;
terminal COMMA, SEMICOLON;

terminal EQ;
terminal EQEQ, NOTEQ, LT, LTEQ, GT, GTEQ;

terminal NOT, ANDAND, OROR;

terminal PLUS, MINUS;
terminal MULT, DIV, MOD, INTEGER_DIV;

terminal BIT_AND, BIT_OR, BIT_XOR, BIT_NOT;

terminal LSHIFT, RSHIFT;

terminal String NUMBER, DECIMAL;//Must convert later
terminal String STRING;

terminal String IDENTIFIER_STRING, IDENTIFIER_DECIMAL, IDENTIFIER_INTEGER;
terminal String LABEL;

terminal LINEEND, COLON;

// Used for precedence only
terminal UMINUS;

/* Non Terminals */
/*  Shortening Map
    stmnt -> Statement
    expr -> Expression
    op -> Operator
    bin -> Binary
    sep -> Separator
    func -> Function
    opt -> Optional
*/

//Statements
//TODO: Reorganize this section a bit
non terminal program;
non terminal Stmnt stmnt;
non terminal StmntList stmnt_list, ex_stmnt_list;
non terminal Stmnt declaration, asig;
non terminal Stmnt conditional, loop;
non terminal Stmnt if_stmnt, on_stmnt, case_list;
non terminal StmntList if_2;
non terminal Stmnt goto_stmnt;
non terminal Stmnt def_stmnt, return_stmnt;
non terminal VarList var_list;
non terminal Stmnt call_stmnt, ret_call_stmnt;
non terminal ExprList expr_list;
non terminal DefParam def_params;
non terminal Stmnt func_call;
non terminal Stmnt simp_func_call, multi_func_call, method_call;
non terminal Stmnt increment_stmnt, swap_stmnt;
non terminal Stmnt print_stmnt;
non terminal ExprList print_list;
non terminal Stmnt input_stmnt;
non terminal Stmnt for_stmnt, while_stmnt, repeat_stmnt;
non terminal sep;
//LATER TODO: read, data, restore, exec, use
//Expressions
non terminal Expr expr, numeric;
non terminal LiteralExpr literal;
non terminal IdExpr id;
non terminal Integer math_op_mult, math_op_sum;
non terminal Integer bin_relation_op, bin_bit_op, bin_logic_op, bit_shift;
non terminal Integer unary_op;

/* Precedence */
precedence left ANDAND, OROR;
precedence left BIT_AND, BIT_OR, BIT_XOR;
precedence left EQEQ, NOTEQ, LT, LTEQ, GT, GTEQ;
precedence left LSHIFT, RSHIFT;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD, INTEGER_DIV;
precedence left UMINUS, NOT, BIT_NOT;

/* Grammar */

start with program;

program     ::= ex_stmnt_list:l     {:l.printTree(0);BuildAstAsDot(l);:}
            ;//TODO: PRINT AST HERE

stmnt_list  ::= stmnt:s sep stmnt_list:l    {:RESULT = new StmntList(s,l);:}
            |   sep stmnt_list:l            {:RESULT = l;:}
            |   stmnt:s sep                 {:RESULT = new StmntList(s,null);:}
            ;
ex_stmnt_list   ::= stmnt:s sep ex_stmnt_list:l {:RESULT = new StmntList(s,l);:}
                |   END sep ex_stmnt_list:l     {:RESULT = new StmntList(new SimpleStmnt(sym.END),l);:}
                |   sep ex_stmnt_list:l         {:RESULT = l;:}
                |   stmnt:s sep                 {:RESULT = new StmntList(s,null);:}
                |   END sep                     {:RESULT = new StmntList(new SimpleStmnt(sym.END),null);:}
                ;
stmnt       ::= declaration:s       {:RESULT = s;:}
            |   asig:s              {:RESULT = s;:}
            |   conditional:s       {:RESULT = s;:}
            |   loop:s              {:RESULT = s;:}
            |   goto_stmnt:s        {:RESULT = s;:}
            |   def_stmnt:s         {:RESULT = s;:}
            |   increment_stmnt:s   {:RESULT = s;:}
            |   swap_stmnt:s        {:RESULT = s;:}
            |   print_stmnt:s       {:RESULT = s;:}
            |   input_stmnt:s       {:RESULT = s;:}
            |   call_stmnt:s        {:RESULT = s;:}
            |   func_call:s         {:RESULT = s;:}
            |   return_stmnt:s      {:RESULT = s;:}
            |   LABEL:l             {:RESULT = new LabelStmnt(l);:}
            |   BREAK               {:RESULT = new SimpleStmnt(sym.BREAK);:}
            |   CONTINUE            {:RESULT = new SimpleStmnt(sym.CONTINUE);:}
            ;
sep         ::= LINEEND
            |   COLON
            ;

//Statements
declaration ::= VAR id:i                        {:RESULT = new DecStmnt(i,null,null);:}
            |   DIM id:i                        {:RESULT = new DecStmnt(i,null,null);:}
            |   VAR id:i LBRACK expr:e RBRACK   {:RESULT = new DecStmnt(i,e,null);:}
            |   DIM id:i LBRACK expr:e RBRACK   {:RESULT = new DecStmnt(i,e,null);:}
            |   VAR asig:a                      {:RESULT = new DecStmnt(((AssignStmnt)a).id,((AssignStmnt)a).arrPos,((AssignStmnt)a).asig);:}
            |   DIM asig:a                      {:RESULT = new DecStmnt(((AssignStmnt)a).id,((AssignStmnt)a).arrPos,((AssignStmnt)a).asig);:}
            ;//TODO: multiple declarations in one line, check if array/var/asig mix is possible  
asig        ::= id:i EQ expr:e                      {:RESULT = new AssignStmnt(i,null,e);:}
            |   id:i LBRACK expr:p RBRACK EQ expr:e {:RESULT = new AssignStmnt(i,p,e);:}
            ;

conditional ::= if_stmnt:s  {:RESULT = s;:}
            |   on_stmnt:s  {:RESULT = s;:}
            ;
if_stmnt    ::= IF expr:e THEN ex_stmnt_list:l if_2:f   {:RESULT = new IfStmnt(e,l,f);:}
            ;
if_2        ::= ELSEIF expr:e THEN ex_stmnt_list:l if_2:f   {:RESULT = new StmntList(new IfStmnt(e,l,f),null);:}
            |   ELSE ex_stmnt_list:l ENDIF                  {:RESULT = l;:}
            |   ENDIF                                       {:RESULT = null;:}
            ;
on_stmnt    ::= ON expr sep case_list WON           {:RESULT = new SimpleStmnt(sym.ON);:}
            ;//TODO
case_list   ::= CASE literal sep ex_stmnt_list case_list    {:RESULT = null;:}
            |   DEFAULT sep ex_stmnt_list case_list         {:RESULT = null;:}
            |   CASE literal sep ex_stmnt_list              {:RESULT = null;:}
            |   DEFAULT sep ex_stmnt_list                   {:RESULT = null;:}
            ;

loop        ::= for_stmnt:s     {:RESULT = s;:}
            |   while_stmnt:s   {:RESULT = s;:}
            |   repeat_stmnt:s  {:RESULT = s;:}
            ;
for_stmnt   ::= FOR id:i EQ numeric:n TO numeric:m sep ex_stmnt_list:l NEXT                 {:RESULT = new ForStmnt(i,n,m,new LiteralExpr<Integer>(new Integer(1)),l);:}
            |   FOR id:i EQ numeric:n TO numeric:m STEP numeric:s sep ex_stmnt_list:l NEXT  {:RESULT = new ForStmnt(i,n,m,s,l);:}
            ;//Check if any expr possible (strings). Check if asig obligatory
while_stmnt ::= WHILE expr:e sep ex_stmnt_list:l WEND   {:RESULT = new WhileStmnt(e,l);:}
            ;
repeat_stmnt::= REPEAT sep ex_stmnt_list:l UNTIL expr:e {:RESULT = new RepeatStmnt(e,l);:}
            ;

goto_stmnt  ::= GOTO LABEL:l    {:RESULT = new GotoStmnt(l,false);:}
            |   GOSUB LABEL:l   {:RESULT = new GotoStmnt(l,true);:}
            ;

def_stmnt   ::= DEF id:i def_params:p stmnt_list:l END  {:RESULT = new DefStmnt(i.name,p.args,p.ret,l);:}
            ;
def_params  ::= LPAREN var_list:l RPAREN sep    {:RESULT = new DefParam(l,null);:}
            |   LPAREN RPAREN sep               {:RESULT = new DefParam(null,null);:}
            |   var_list:l OUT var_list:r sep   {:RESULT = new DefParam(l,r);:}
            |   OUT var_list:r sep              {:RESULT = new DefParam(null,r);:}
            |   sep                             {:RESULT = new DefParam(null,null);:}
            ;
return_stmnt::= RETURN expr:e   {:RESULT = new RetStmnt(e);:}
            |   RETURN          {:RESULT = new RetStmnt(null);:}
            ;

call_stmnt  ::= CALL STRING:s                                   {:RESULT = new CallStmnt(s,null,null);:}
            |   CALL STRING:s COMMA expr_list:p                 {:RESULT = new CallStmnt(s,p,null);:}
            |   CALL STRING:s OUT var_list:r                    {:RESULT = new CallStmnt(s,null,r);:}
            |   CALL STRING:s COMMA expr_list:p OUT var_list:r  {:RESULT = new CallStmnt(s,p,r);:}
            ;
ret_call_stmnt  ::= CALL LPAREN STRING:s RPAREN                     {:RESULT = new CallStmnt(s,null,null);:}
                |   CALL LPAREN STRING:s COMMA expr_list:l RPAREN   {:RESULT = new CallStmnt(s,l,null);:} 
                ;

func_call   ::= simp_func_call:s    {:RESULT = s;:}
            |   multi_func_call:s   {:RESULT = s;:}
            |   method_call:s       {:RESULT = s;:}
            ;
simp_func_call  ::= id:i LPAREN expr:e COMMA expr_list:l RPAREN {:RESULT = new CallStmnt(i.name,new ExprList(e,l),null);:}
                |   id:i LPAREN expr:e RPAREN                   {:RESULT = new CallStmnt(i.name,new ExprList(e,null),null);:}
                |   id:i LPAREN RPAREN                          {:RESULT = new CallStmnt(i.name,null,null);:}
                ;//I have no idea why LPAREN expr_list RPAREN doesn't work, but this does.
multi_func_call ::= id:i expr_list:p OUT var_list:r {:RESULT = new CallStmnt(i.name,p,r);:}
                |   id:i OUT var_list:r             {:RESULT = new CallStmnt(i.name,null,r);:}
                ;
method_call ::= id:i    {:RESULT = new CallStmnt(i.name, null, null);:}
            ;//Hopefully won't cause trouble

var_list    ::= id:i COMMA var_list:l   {:RESULT = new VarList(i,l);:}
            |   id:i                    {:RESULT = new VarList(i,null);:}
            ;

expr_list   ::= expr:e COMMA expr_list:l    {:RESULT = new ExprList(e,l);:}
            |   expr:e                      {:RESULT = new ExprList(e,null);:}
            ;

increment_stmnt ::= INC id:i                {:RESULT = new AssignStmnt(i,null,new BinExpr(i,new LiteralExpr<Integer>(new Integer(1)),sym.PLUS));:}
                |   INC id:i COMMA expr:e   {:RESULT = new AssignStmnt(i,null,new BinExpr(i,e,sym.PLUS));:}
                |   DEC id:i                {:RESULT = new AssignStmnt(i,null,new BinExpr(i,new LiteralExpr<Integer>(new Integer(1)),sym.MINUS));:}
                |   DEC id:i COMMA expr:e   {:RESULT = new AssignStmnt(i,null,new BinExpr(i,e,sym.MINUS));:}
                ;

swap_stmnt  ::= SWAP id:i1 COMMA id:i2    {:RESULT = new SwapStmnt(i1, i2);:}
            ;

print_stmnt ::= PRINT print_list:l      {:RESULT = new PrintStmnt(l);:}
            |   QUESTION print_list:l   {:RESULT = new PrintStmnt(l);:}
            ;
print_list  ::= expr:e COMMA print_list:l       {:RESULT = new ExprList(e,new ExprList(new LiteralExpr<String>("  "),l));:}
            |   expr:e SEMICOLON print_list:l   {:RESULT = new ExprList(e,l);:}
            |   expr:e                          {:RESULT = new ExprList(e,new ExprList(new LiteralExpr<String>("\n"),null));:}
            |   COMMA                           {:RESULT = new ExprList(new LiteralExpr<String>("  \n"),null);:}
            |   SEMICOLON                       {:RESULT = null;:}
            ;

input_stmnt ::= INPUT STRING:s SEMICOLON var_list:l             {:RESULT = new InputStmnt(s+"?",l);:}
            |   INPUT STRING:s COMMA var_list:l                 {:RESULT = new InputStmnt(s,l);:}
            |   INPUT var_list:l                                {:RESULT = new InputStmnt("",l);:}
            |   LINPUT STRING:s SEMICOLON IDENTIFIER_STRING:i   {:RESULT = new InputStmnt(s,new VarList(new IdExpr(sym.IDENTIFIER_STRING,i),null));:}
            ;

//Expressions
expr    ::= expr:e1 bin_logic_op:o expr:e2      {:RESULT = new BinExpr(e1,e2,o.intValue());:}
        |   expr:e1 bin_bit_op:o expr:e2        {:RESULT = new BinExpr(e1,e2,o.intValue());:}
        |   expr:e1 bin_relation_op:o expr:e2   {:RESULT = new BinExpr(e1,e2,o.intValue());:}
        |   expr:e1 bit_shift:o expr:e2         {:RESULT = new BinExpr(e1,e2,o.intValue());:}
        |   expr:e1 math_op_sum:o expr:e2       {:RESULT = new BinExpr(e1,e2,o.intValue());:}
        |   expr:e1 math_op_mult:o expr:e2      {:RESULT = new BinExpr(e1,e2,o.intValue());:}
        |   unary_op:o expr:e                   {:RESULT = new UnExpr(e,o.intValue());:}
        |   LPAREN expr:e RPAREN                {:RESULT = e;:}
        |   literal:e                           {:RESULT = e;:}
        |   id:e                                {:RESULT = e;:}
        |   id:e LBRACK expr:p RBRACK           {:RESULT = e;:}
        |   simp_func_call:e                    {:RESULT = null;:}
        |   ret_call_stmnt:e                    {:RESULT = null;:}
        ;//TODO

//Expression Terminal Groups
unary_op        ::= MINUS               {:RESULT = new Integer(sym.MINUS);:}
                    %prec UMINUS
                |   NOT                 {:RESULT = new Integer(sym.NOT);:}
                |   BIT_NOT             {:RESULT = new Integer(sym.BIT_NOT);:}
                ;
math_op_mult    ::= MULT        {:RESULT = new Integer(sym.MULT);:}
                |   DIV         {:RESULT = new Integer(sym.DIV);:}
                |   MOD         {:RESULT = new Integer(sym.MOD);:}
                |   INTEGER_DIV {:RESULT = new Integer(sym.INTEGER_DIV);:}
                ;
math_op_sum     ::= PLUS    {:RESULT = new Integer(sym.PLUS);:}
                |   MINUS   {:RESULT = new Integer(sym.MINUS);:}
                ;
bit_shift       ::= LSHIFT  {:RESULT = new Integer(sym.LSHIFT);:}
                |   RSHIFT  {:RESULT = new Integer(sym.RSHIFT);:}
                ;
bin_relation_op ::= EQEQ    {:RESULT = new Integer(sym.EQEQ);:}
                |   NOTEQ   {:RESULT = new Integer(sym.NOTEQ);:}
                |   LT      {:RESULT = new Integer(sym.LT);:}
                |   LTEQ    {:RESULT = new Integer(sym.LTEQ);:}
                |   GT      {:RESULT = new Integer(sym.GT);:}
                |   GTEQ    {:RESULT = new Integer(sym.GTEQ);:}
                ;
bin_bit_op      ::= BIT_AND {:RESULT = new Integer(sym.BIT_AND);:}
                |   BIT_OR  {:RESULT = new Integer(sym.BIT_OR);:}
                |   BIT_XOR {:RESULT = new Integer(sym.BIT_XOR);:}
                ;
bin_logic_op    ::= ANDAND  {:RESULT = new Integer(sym.ANDAND);:}
                |   OROR    {:RESULT = new Integer(sym.OROR);:}
                ;
literal     ::= NUMBER:n    {:RESULT = new LiteralExpr<Integer>(Integer.parseInt(n));:}
            |   DECIMAL:n   {:RESULT = new LiteralExpr<Double>(Double.parseDouble(n));:}
            |   STRING:n    {:RESULT = new LiteralExpr<String>(n);:}
            |   TRUE        {:RESULT = new LiteralExpr<Integer>(new Integer(1));:}
            |   FALSE       {:RESULT = new LiteralExpr<Integer>(new Integer(0));:}
            ;
numeric     ::= IDENTIFIER_INTEGER:i    {:RESULT = new IdExpr(sym.IDENTIFIER_INTEGER, i);:}
            |   IDENTIFIER_DECIMAL:i    {:RESULT = new IdExpr(sym.IDENTIFIER_DECIMAL, i);:}
            |   NUMBER:n                {:RESULT = new LiteralExpr<Integer>(Integer.parseInt(n));:}
            |   DECIMAL:n               {:RESULT = new LiteralExpr<Double>(Double.parseDouble(n));:}
            |   TRUE                    {:RESULT = new LiteralExpr<Integer>(new Integer(1));:}
            |   FALSE                   {:RESULT = new LiteralExpr<Integer>(new Integer(0));:}
            ;
id          ::= IDENTIFIER_INTEGER:i    {:RESULT = new IdExpr(sym.IDENTIFIER_INTEGER, i);:}
            |   IDENTIFIER_DECIMAL:i    {:RESULT = new IdExpr(sym.IDENTIFIER_DECIMAL, i);:}
            |   IDENTIFIER_STRING:i     {:RESULT = new IdExpr(sym.IDENTIFIER_STRING, i);:}
            ;
