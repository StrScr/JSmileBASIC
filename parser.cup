/*
    SmileBASIC Syntax Analyzer by StrScr
    To be used with CUP.

    TODO:
        Check other TODOs throughout code
        Allow for multidimensional arrays (Currently one-dimensional)
*/

package JSmileBASIC;

import java.io.*;
import java_cup.runtime.*;

parser code
{:
    public void syntax_error(Symbol s){
        report_error("Error de sintaxis. Linea: " + (s.right + 1) +
            " Columna: " + s.left + ". Texto: \"" + s.value + "\"", null);
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        report_fatal_error("Fatal Error: " + s.value, null);
    }

:}

/* Terminals */

terminal IF, THEN, ELSE, ELSEIF, ENDIF;
terminal ON, CASE, DEFAULT, WON;

terminal FOR, TO, STEP, NEXT;
terminal WHILE, WEND;
terminal REPEAT, UNTIL;
terminal CONTINUE, BREAK;

//terminal STOP;

terminal GOTO, GOSUB;

terminal DEF, CALL, RETURN, OUT, END;
//terminal COMMON;

terminal VAR, DIM;
terminal INC, DEC, SWAP;

terminal PRINT, QUESTION;

terminal INPUT, LINPUT;

//terminal READ, DATA, RESTORE;

//terminal EXEC, USE;

terminal TRUE, FALSE;

terminal LPAREN, RPAREN;
terminal LBRACK, RBRACK;
terminal COMMA, SEMICOLON;

terminal EQ;
terminal EQEQ, NOTEQ, LT, LTEQ, GT, GTEQ;

terminal NOT, ANDAND, OROR;

terminal PLUS, MINUS;
terminal MULT, DIV, MOD, INTEGER_DIV;

terminal BIT_AND, BIT_OR, BIT_XOR, BIT_NOT;

terminal LSHIFT, RSHIFT;

terminal NUMBER, DECIMAL;
terminal STRING;

terminal IDENTIFIER_STRING, IDENTIFIER_DECIMAL, IDENTIFIER_INTEGER;
terminal LABEL;

terminal LINEEND, COLON;

// Used for precedence only
terminal UMINUS;

/* Non Terminals */
/*  Shortening Map
    stmnt -> Statement
    expr -> Expression
    op -> Operator
    bin -> Binary
    sep -> Separator
    func -> Function
    opt -> Optional
*/

//Statements
//TODO: Reorganize this section a bit
non terminal stmnt_list, stmnt;
non terminal declaration, asig;
non terminal conditional, loop;
non terminal if_stmnt, if_2, on_stmnt, case_list;
non terminal goto_stmnt;
non terminal def_stmnt, var_list;
non terminal call_stmnt, ret_call_stmnt, expr_list, opt_expr_list;
non terminal def_params;
non terminal func_call;
non terminal simp_func_call, multi_func_call, method_call;
non terminal increment_stmnt, swap_stmnt;
non terminal print_stmnt, print_list;
non terminal input_stmnt;
non terminal for_stmnt, while_stmnt, repeat_stmnt, stmnt_loop_list, stmnt_loop;
non terminal sep;
//LATER TODO: read, data, restore, exec, use
//Expressions
non terminal expr, literal, numeric, id;
non terminal math_op_mult, math_op_sum;
non terminal bin_relation_op, bin_bit_op, bin_logic_op, bit_shift, unary_op;
//Special
non terminal empty;

/* Precedence */
precedence left ANDAND, OROR;
precedence left BIT_AND, BIT_OR, BIT_XOR;
precedence left EQEQ, NOTEQ, LT, LTEQ, GT, GTEQ;
precedence left LSHIFT, RSHIFT;
precedence left PLUS, MINUS;
precedence left MULT, DIV, MOD, INTEGER_DIV;
precedence left UMINUS, NOT, BIT_NOT;

/* Grammar */

start with stmnt_list;

stmnt_list  ::= stmnt
            |   stmnt sep stmnt_list
            ;
stmnt       ::= declaration | asig | conditional | loop | goto_stmnt | def_stmnt | increment_stmnt
            |   swap_stmnt | print_stmnt | input_stmnt | call_stmnt | func_call
            |   LABEL | END | RETURN
            |   empty
            ;
sep         ::= LINEEND
            |   COLON
            ;

//Statements
declaration ::= VAR id
            |   DIM id
            |   VAR id LBRACK expr RBRACK
            |   DIM id LBRACK expr RBRACK
            |   VAR asig
            |   DIM asig
            ;//TODO: multiple declarations in one line, check if array/var/asig mix is possible  
asig        ::= id EQ expr
            |   id LBRACK expr RBRACK EQ expr
            ;

conditional ::= if_stmnt
            |   on_stmnt
            ;
if_stmnt    ::= IF expr THEN stmnt_list if_2 sep ENDIF
            ;
if_2        ::= sep ELSEIF expr THEN stmnt_list sep if_2
            |   sep ELSE stmnt_list
            |   empty
            ;
on_stmnt    ::= ON expr sep case_list sep WON
            ;
case_list   ::= CASE literal sep stmnt_loop_list case_list
            |   DEFAULT sep stmnt_loop_list case_list
            |   empty
            ;

loop        ::= for_stmnt
            |   while_stmnt
            |   repeat_stmnt
            ;
for_stmnt   ::= FOR id EQ numeric TO numeric sep stmnt_list sep NEXT
            |   FOR id EQ numeric TO numeric STEP numeric sep stmnt_list sep NEXT
            ;//Check if any expr possible (strings). Check if asig obligatory
while_stmnt ::= WHILE expr sep stmnt_loop_list sep WEND
            ;
repeat_stmnt::= REPEAT sep stmnt_loop_list sep UNTIL expr
            ;
stmnt_loop_list ::= stmnt_loop
                |   stmnt_loop sep stmnt_loop_list
                ;
stmnt_loop  ::= stmnt
            |   BREAK
            |   CONTINUE
            ;

goto_stmnt  ::= GOTO LABEL
            |   GOSUB LABEL
            ;

def_stmnt   ::= DEF id def_params sep stmnt_list sep END
            ;
def_params  ::= LPAREN var_list RPAREN
            |   LPAREN RPAREN
            |   var_list OUT var_list
            |   OUT var_list
            |   empty
            ;

call_stmnt  ::= CALL STRING opt_expr_list
            |   CALL STRING opt_expr_list OUT var_list
            ;
ret_call_stmnt  ::= CALL LPAREN STRING opt_expr_list RPAREN
                ;

func_call   ::= simp_func_call
            |   multi_func_call
            |   method_call
            ;
simp_func_call  ::= id LPAREN var_list RPAREN
                |   id LPAREN RPAREN
                ;
multi_func_call ::= id var_list OUT var_list
                |   id OUT var_list
                ;
method_call ::= id
            ;//Hopefully won't cause trouble

var_list    ::= id COMMA var_list
            |   id
            ;

expr_list   ::= expr COMMA expr_list
            |   expr
            ;
opt_expr_list   ::= COMMA expr_list
                |   empty
                ;//Used with CALL

increment_stmnt ::= INC id
                |   INC id COMMA expr
                |   DEC id
                |   DEC id COMMA expr
                ;

swap_stmnt  ::= SWAP id COMMA id
            ;

print_stmnt ::= PRINT print_list
            |   QUESTION print_list
            ;
print_list  ::= expr COMMA print_list
            |   expr SEMICOLON print_list
            |   expr
            |   empty
            ;

input_stmnt ::= INPUT STRING SEMICOLON var_list
            |   INPUT STRING COMMA var_list
            |   INPUT var_list
            |   LINPUT STRING SEMICOLON IDENTIFIER_STRING
            ;

//Expressions
expr    ::= expr bin_logic_op expr
        |   expr bin_bit_op expr
        |   expr bin_relation_op expr
        |   expr bit_shift expr
        |   expr math_op_sum expr
        |   expr math_op_mult expr
        |   unary_op expr
        |   LPAREN expr RPAREN
        |   literal
        |   id
        |   id LBRACK expr RBRACK
        |   simp_func_call
        |   ret_call_stmnt
        ;

//Expression Terminal Groups
unary_op        ::= MINUS %prec UMINUS | NOT | BIT_NOT;
math_op_mult    ::= MULT | DIV | MOD | INTEGER_DIV;
math_op_sum     ::= PLUS | MINUS;
bit_shift       ::= LSHIFT | RSHIFT;
bin_relation_op ::= EQEQ | NOTEQ | LT | LTEQ | GT | GTEQ;
bin_bit_op      ::= BIT_AND | BIT_OR | BIT_XOR;
bin_logic_op    ::= ANDAND | OROR;
literal     ::= NUMBER | DECIMAL | STRING | TRUE | FALSE;
numeric     ::= IDENTIFIER_INTEGER | IDENTIFIER_DECIMAL | NUMBER | DECIMAL | TRUE | FALSE;
id          ::= IDENTIFIER_INTEGER | IDENTIFIER_DECIMAL | IDENTIFIER_STRING;

//Special
empty   ::=;
