/*
    SmileBASIC Syntax Analyzer by StrScr
    To be used with CUP.
*/

package JSmileBASIC;

import java.io.*;
import java_cup.runtime.*;

parser code
{:
    public void syntax_error(Symbol s){
        report_error("Error de sintaxis. Linea: " + (s.right + 1) +
            " Columna: " + s.left + ". Texto: \"" + s.value + "\"", null);
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        report_fatal_error("Fatal Error: " + s.value, null);
    }

:}

/* Terminals */

terminal IF, THEN, ELSE, ELSEIF, ENDIF;
terminal ON, CASE, DEFAULT, WON;

terminal FOR, TO, STEP, NEXT;
terminal WHILE, WEND;
terminal REPEAT, UNTIL;
terminal CONTINUE, BREAK;

terminal STOP;

terminal GOTO, GOSUB;

terminal DEF, COMMON, CALL, RETURN, OUT, END;

terminal VAR, DIM;
terminal INC, DEC, SWAP;

terminal PRINT, QUESTION;

terminal INPUT, LINPUT;

terminal READ, DATA, RESTORE;

terminal EXEC, USE;

terminal TRUE, FALSE;

terminal LPAREN, RPAREN;
terminal LBRACK, RBRACK;
terminal COMMA, SEMICOLON;

terminal EQ;
terminal EQEQ, NOTEQ, LT, LTEQ, GT, GTEQ;

terminal NOT, ANDAND, OROR;

terminal PLUS, MINUS;
terminal MULT, DIV, MOD, INTEGER_DIV;

terminal BIT_AND, BIT_OR, BIT_XOR, BIT_NOT;

terminal LSHIFT, RSHIFT;

terminal NUMBER, DECIMAL;
terminal STRING;

terminal IDENTIFIER_STRING, IDENTIFIER_DECIMAL, IDENTIFIER_INTEGER;
terminal LABEL;

terminal LINEEND, COLON;

// Used for precedence only
terminal UMINUS;

/* Non Terminals */
/*  Shortening Map
    stmnt -> Statement
    expr -> Expression
    op -> Operator
    bin -> Binary
    sep -> Separator
*/

non terminal stmnt_list, stmnt;
non terminal expr, literal, id;
non terminal math_op_mult, math_op_sum;
non terminal bin_relation_op, bin_bit_op, bin_logic_op, bit_shift, unary_op;
non terminal sep;
//Statements
non terminal declaration, asig;
non terminal conditional, loop;
non terminal if_stmnt, if_2, on_stmnt;
non terminal goto_stmnt;
non terminal def_stmnt, call_stmnt;
non terminal increment_stmnt, swap_stmnt;
non terminal print_stmnt;
non terminal for_stmnt, while_stmnt, repeat_stmnt, stmnt_loop_list, stmnt_loop;
non terminal statement_inside_while;
non terminal bool_exp, relational_expression, logical_expression, relational_expression;
non terminal relational_operators, logical_operators, logical_operators;
//TODO: read, data, restore, exec, use

/* Precedence */

//TODO

/* Grammar */

start with stmnt_list;

stmnt_list   ::= stmnt
            |   stmnt sep stmnt_list
            ;
stmnt       ::= declaration | asig | conditional | loop | goto_stmnt | def_stmnt | increment_stmnt
            | swap_stmnt | print_stmnt | call_stmnt | sep
            | LABEL | STOP | END
            ;//TODO
sep         ::= LINEEND | COLON;
literal     ::= NUMBER | DECIMAL | STRING | TRUE | FALSE;
id          ::= IDENTIFIER_INTEGER | IDENTIFIER_DECIMAL | IDENTIFIER_STRING;

bool_exp ::= relational_expression:rl logical_expression:le;

relational_expression   ::=  expr:e1 relational_operators:r expr:e2
							           | LPAREN relational_expression:rl RPAREN
							           | error {: parser.report_error("relational_expression","ERROR"); :} LT expr

                         | error {: parser.report_error("relational_expression","ERROR"); :} GT expr

                         | error  {: parser.report_error("relational_expression","ERROR"); :} LTEQ expr

                         | error {: parser.report_error("relational_expression" ,"ERROR"); :} GTEQ expr ;

relational_operators ::=  LTEQ
					| LT
					| GT
					| GTEQ
					| EQEQ
					| NOTEQ;

logical_expression ::= logical_operators:lo bool_exp:bo
					|	;

logical_operators ::= ANDAND
					| OROR
					;

//Statements
declaration ::= VAR id | DIM id
            |   VAR asig | DIM asig
            ;//include arrays
asig        ::= id EQ expr
            |   id LBRACK expr RBRACK EQ expr
            ;

conditional ::= if_stmnt | on_stmnt;
if_stmnt    ::= IF expr THEN stmnt_list if_2 sep ENDIF;
if_2        ::= sep ELSEIF expr THEN stmnt_list sep if_2
            |   sep ELSE stmnt_list
            |;

loop        ::= for_stmnt | while_stmnt | repeat_stmnt;

for_stmnt   ::=; FOR expr_for STEP INT sep stmnt_list sep NEXT;

expr_for  ::= sep ID EQ INT sep ;

while_stmnt ::= WHILE bool_exp:b statement_inside_while:s WEND

statement_inside_while ::= sep stmnt_list:sl sep ;

repeat_stmnt::= REPEAT statement_inside_while UNTIL bool_exp;

stmnt_loop_list ::= stmnt_loop
                |   stmnt_loop sep stmnt_loop_list;
stmnt_loop  ::= stmnt | BREAK | CONTINUE;

//Expression Terminal Groups
unary_op        ::= MINUS %prec UMINUS | NOT | BIT_NOT;
math_op_mult    ::= MULT | DIV | MOD | INTEGER_DIV;
math_op_sum     ::= PLUS | MINUS;
bit_shift       ::= LSHIFT | RSHIFT;
bin_relation_op ::= EQEQ | NOTEQ | LT | LTEQ | GT | GTEQ;
bin_bit_op      ::= BIT_AND | BIT_OR | BIT_XOR;
bin_logic_op    ::= ANDAND | OROR;
